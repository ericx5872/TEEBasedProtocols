theory FIDO2_WebAuthen_ECDAA_Diff_NSW_R

begin

builtins: hashing, signing

functions:  
            blind/2,
            blind_sig/2,
            verify_blind_sig/3,
            verify_bilinear_pairing/2,
            IssuerSk/0[private],  // The private key of Issuser
            Ij1/0[private],
            Ij2/0[private],
            nsToken/1[private],   // access token for RAM/Flash of Non-Secure world on TEE-based platform   (e.g. Client)
            sToken/1[private],    // access token for RAM/Flash of Secure world on TEE-based platform       (e.g. Authenticator)
            svrToken/1[private],  // access token for RAM/Flash of server in WebAuthn protocol              (e.g. Server)
            iToken/1[private]     // access token for RAM/Flash of Issuer of ECDAA certificate              (e.g. Issuer)


/* ******************** Initialization step ( I1 ) ******************** */
/* ******************** Initialization step ( I1 ) ******************** */
/* ******************** Initialization step ( I1 ) ******************** */
/* ******************** Initialization step ( I1 ) ******************** */
/* ******************** Initialization step ( I1 ) ******************** */

/*  (I1) In the script, the in-factory ECDAA-join mode is considered. In this mode, physical proximity is used 
    to locally establish the trust between the ECDAA Issuer and Authenticator. The attestation keys
    and credential have been generated by Issuer before Authenticator and Client being shipped.
    *** The attestation key pair: "~attestSk" & "pk(~attestSk)" are generated and stored in Flash of Authenticator.
    *** The attestation credential: generated for the attestation key pair and stored in Flash of both 
*/
rule EcdaaIssuer_InFactorySetup:
      let
        // Two nonces are generated by Issuer for two Authenticators
        ij1 = Ij1()
        ij2 = Ij2()
        // Two blinded credentials are generated by Issuer for two Authenticators
        attestCred1 = blind(pk(~attestSk1), ij1)
        attestCred2 = blind(pk(~attestSk2), ij2)
      in
      [
        Fr( ~attestSk1 ),
        Fr( ~attestSk2 )
      ]
    --[
        UniqueSetup( 'ISSUER_ECDAA_SETUP' )
       ]->
      [ 
        // Issuer stores the generated attestation private keys and credentials in flash (i.e. Flash) of itself
        !Flash( iToken($IssuerID), <~attestSk1,attestCred1> ),
        !Flash( iToken($IssuerID), <~attestSk2,attestCred2> ),
        // Issuer stores the generated attestation credentials in Flash of two Clients
        !Flash( nsToken($ClientID1), attestCred1 ),
        !Flash( nsToken($ClientID2), attestCred2 ),
        // Issuer stores the generated attestation private keys and credentials in Flash of two Authenticators with same AAGUID
        !Flash( sToken($AAGUID), <~attestSk1,attestCred1> ),
        !Flash( sToken($AAGUID), <~attestSk2,attestCred2> )
      ]


/* ******************** Simplified Registration step ( SR1 ) ******************** */
/* ******************** Simplified Registration step ( SR1 ) ******************** */
/* ******************** Simplified Registration step ( SR1 ) ******************** */
/* ******************** Simplified Registration step ( SR1 ) ******************** */
/* ******************** Simplified Registration step ( SR1 ) ******************** */

/*  (SR1) To check authenticator unlinkability (i.e. Server can't distinguish different authenticators 
    to register) in ECDAA-attesation FIDO WebAuthen protocol, all the generated nonces and random numbers 
    are captured in this script.

    However, for simplicity, $UserName is ignored to check authenticator unlinkability.
    We suppose users carefully choose their usernames so that Server can't distinguish different authenticators 
    by using their usernames.    
*/
rule DIFF_ECDAA_SIGN:
      let
        // Issuer of ECDAA certificate generates attestation key credentials
        attestCred1 = blind(pk(attestSk1), ij1)
        attestCred2 = blind(pk(attestSk2), ij2)

        // Clients receive chalR* from Server and generate cilentData
        clientData1a = <~chalR1a, $ClientID1>
        clientData1b = <~chalR1b, $ClientID1>
        clientData2 = <~chalR2, $ClientID2>

        clientDataHash1a = h(clientData1a)
        clientDataHash1b = h(clientData1b)
        clientDataHash2 = h(clientData2)

        // Clients generate nonces "~l*" and blinds the attestation credential
        bldAttCred1a = blind(attestCred1, ~l1a )
        bldAttCred1b = blind(attestCred1, ~l1b )
        bldAttCred2 = blind(attestCred2, ~l2 )

        // Authenticators generate blinded ECDAA attestation signatures
        authData1a = <$SvrID, ~nonce1a, $AAGUID, pk(~credSk1a)>
        authData1b = <$SvrID, ~nonce1b, $AAGUID, pk(~credSk1b)>
        authData2 = <$SvrID, ~nonce2, $AAGUID, pk(~credSk2)>

        KRD1a = <authData1a, clientDataHash1a>
        KRD1b = <authData1b, clientDataHash1b>
        KRD2 = <authData2, clientDataHash2>

        c1a = blind(<h(KRD1a),bldAttCred1a>, <~r1a,~n1a> )
        c1b = blind(<h(KRD1b),bldAttCred1b>, <~r1b,~n1b> )
        c2 = blind(<h(KRD2),bldAttCred2>, <~r2,~n2> )

        bldAttSig1a = <c1a, blind_sig(c1a, attestSk1), bldAttCred1a, ~n1a>
        bldAttSig1b = <c1b, blind_sig(c1b, attestSk1), bldAttCred1b, ~n1b>
        bldAttSig2 = <c2, blind_sig(c2, attestSk2), bldAttCred2, ~n2>

        attestObj1a = <authData1a, bldAttSig1a>
        attestObj1b = <authData1b, bldAttSig1b>
        attestObj2 = <authData2, bldAttSig2>
      in
      [ 
      	// Attestation keys are generated and stored in Authenticators by Issuer,
        // and read from NV Storage of Authenticators.
        !Flash( sToken($AAGUID), <attestSk1,attestCred1> ),
        !Flash( sToken($AAGUID), <attestSk2,attestCred2> ),

        // Attestation credentials are generated and stored in Clients by Issuer,
        // and read from NV Storage of Clients.
        !Flash( nsToken($ClientID1), attestCred1 ),
        !Flash( nsToken($ClientID2), attestCred2 ),

      	// Server generates challenge nonces "~chalR*" for attestation
        Fr( ~chalR1a ),
        Fr( ~chalR1b ),
        Fr( ~chalR2 ), 

        // Two Clients generate nonces "~l*" for attestation credentials
        Fr( ~l1a ),
        Fr( ~l1b ),
        Fr( ~l2 ),

        // Two Authenticators generate credential key pairs and IDs for authentication 
        Fr( ~credSk1a ),
        Fr( ~credSk1b ),
        Fr( ~credSk2 ),

        // Authenticators generate nonces "~nonce*" (instead of counter in the script) during registration.
        // The counter could be constant at zero if Authenticator don't support a global or per credential counter.
        Fr( ~nonce1a ),
        Fr( ~nonce1b ),
        Fr( ~nonce2 ),

        // Authenticators generate nonces "~r*" and "~n*" for generating blinded ECDAA attestation signature
        Fr( ~r1a ),
        Fr( ~r1b ),
        Fr( ~r2 ),

        Fr( ~n1a ),
        Fr( ~n1b ),
        Fr( ~n2 )
      ] 
	--[
        UniqueSign( 'CLIENT_ECDAA_SIGN' ),
        Finished()
      ]->
      [ 
        // All the RAM/Flash states are captured 
        Out(< svrToken($SvrID), ~chalR1a >), 
        Out(< svrToken($SvrID), ~chalR1b >), 
        Out(< svrToken($SvrID), ~chalR2 >), 

        RAM( nsToken($ClientID1), ~chalR1a ),
        RAM( nsToken($ClientID1), ~chalR1b ),
        RAM( nsToken($ClientID2), ~chalR2 ),

        RAM( nsToken($ClientID1), ~l1a ),
        RAM( nsToken($ClientID1), ~l1b ),
        RAM( nsToken($ClientID2), ~l2 ),

        RAM( sToken($AAGUID), ~l1a ),
        RAM( sToken($AAGUID), ~l1b ),
        RAM( sToken($AAGUID), ~l2 ),

        RAM( sToken($AAGUID), <~credSk1a, ~nonce1a, ~r1a, ~n1a>),
        RAM( sToken($AAGUID), <~credSk1b, ~nonce1b, ~r1b, ~n1b>),
        RAM( sToken($AAGUID), <~credSk2, ~nonce2, ~r2, ~n2>),

		!Flash( sToken($AAGUID), <$SvrID, $UserID1a, $UserName1a, ~credSk1a > ),
        !Flash( sToken($AAGUID), <$SvrID, $UserID1b, $UserName1b, ~credSk1b> ),
		!Flash( sToken($AAGUID), <$SvrID, $UserID2, $UserName2, ~credSk2> ),

        // The attestation object is generated and sent by Authenticator, 
        // forwarded by Client and finally received by Server. 
        // Here, three attestation objects, generated by two authenticators A and B. 
        // The three attestation objects are given to same attacker (e.g. Server) 
        // to test the unlinkability of authenticators.
        Out( <attestObj1a, diff(attestObj1b, attestObj2)> )
      ]


////////////////////////////////////////////////////////////////////////////
// Server is corrupted, and the attacker can read AND/OR modify
// the Server-related RAM, flash and channels.
////////////////////////////////////////////////////////////////////////////

// rule SvrAttacker_Read_SvrFlash:
//     [ !Flash(svrToken($SvrID), x) ]   --[ Reveal($SvrID, x) ]->    [ Out(x) ]

// rule SvrAttacker_Read_SvrRAM:
//     [ RAM(svrToken($SvrID), x) ]  --[ Reveal($SvrID, x) ]->    [ Out(x) ]

// rule SvrAttacker_Write_SvrFlash:
//     [ !Flash(svrToken($SvrID), x),  In(y) ]  --[ Modification($SvrID, x, y) ]->    [ !Flash(svrToken($SvrID), y) ]

// rule SvrAttacker_Write_SvrRAM:
//     [ RAM(svrToken($SvrID), x),  In(y) ]   --[ Modification($SvrID, x, y) ]->    [ !Flash(svrToken($SvrID), y) ]


////////////////////////////////////////////////////////////////////////////
// Secure world is corrupted, and the attacker can read AND/OR modify
// the Secure-world-related RAM, flash and channels.
////////////////////////////////////////////////////////////////////////////

// rule SwAttacker_Read_SwFlash:
//     [ !Flash(sToken($AAGUID), x) ]   --[ Reveal($AAGUID, x) ]->    [ Out(x) ]

// rule SwAttacker_Read_SwRAM:
//     [ RAM(sToken($AAGUID), x) ]  --[ Reveal($AAGUID, x) ]->    [ Out(x) ]

// rule SwAttacker_Write_SwFlash:
//     [ !Flash(sToken($AAGUID), x),  In(y) ]  --[ Modification($AAGUID, x, y) ]->    [ !Flash(sToken($AAGUID), y) ]

// rule SwAttacker_Write_SwRAM:
//     [ RAM(sToken($AAGUID), x),  In(y) ]   --[ Modification($AAGUID, x, y) ]->    [ !Flash(sToken($AAGUID), y) ]


////////////////////////////////////////////////////////////////////////////
// Non-secure world is corrupted, and the attacker can read AND/OR modify
// the NS-World-related RAM, flash and channels.
////////////////////////////////////////////////////////////////////////////

rule NswAttacker_Read_NswFlash:
    [ !Flash(nsToken($ClientID), x)  ]   --[ Reveal($ClientID, x) ]->    [ Out(x) ]

rule NswAttacker_Read_NswRAM:
    [ RAM(nsToken($ClientID), x)   ]  --[ Reveal($ClientID, x) ]->    [ Out(x) ]    

// rule NswAttacker_Write_NswFlash:
//     [ !Flash(nsToken($ClientID), x),  In( y ) ]  --[ Modification($ClientID, x, y) ]->    [ !Flash(nsToken($ClientID), y) ]

// rule NswAttacker_Write_NswRAM:
//     [ RAM(nsToken($ClientID), x),  In( y ) ]   --[ Modification($ClientID, x, y) ]->    [ !Flash(nsToken($ClientID), y) ]


// Protocol Restrictions
restriction issuer_setup:     "All #i #j x. UniqueSetup( x ) @ #i & UniqueSetup( x ) @ #j ==> #i = #j"
restriction client_sign:      "All #i #j x. UniqueSign( x ) @ #i & UniqueSign( x ) @ #j ==> #i = #j"


// lemma functional_correctness: exists-trace
// "
// Ex #r .
//     // There exists a successful ECDAA-Sign operation at the Client side
//     Finished( ) @ r 
// "


end