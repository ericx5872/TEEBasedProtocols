theory FIDO2_WebAuthen_ECDAA_Svr_RW_NSW_RW_SW_R

begin

builtins: hashing, signing

functions:  
            blind/2,
            blind_sig/2,
            verify_blind_sig/3,
            verify_bilinear_pairing/2,
            IssuerSk/0[private],  // The private key of Issuser
            nsToken/1[private],   // access token for RAM/Flash of Non-Secure world on TEE-based platform   (e.g. Client)
            sToken/1[private],    // access token for RAM/Flash of Secure world on TEE-based platform       (e.g. Authenticator)
            svrToken/1[private],  // access token for RAM/Flash of server in WebAuthn protocol              (e.g. Server)
            iToken/1[private]     // access token for RAM/Flash of Issuer of ECDAA certificate              (e.g. Issuer)

equations: 
            // Random numbers: used to blind the credentials and signatures
            // "ij" is generated by the Issuer of ECDAA certificate,
            // "l" is generated by the Client, 
            // "r" and "n" are generated by the Authenticator.
            verify_blind_sig( 
                          // Blind signature s = blind_sig(c, attestSk) ( s in ECDAA protocol)
                          blind_sig( blind(<h(KRD),blind(blind(<pk(attestSk),issuerSk>,ij),l)>, <r,n>), attestSk ), 
                          // Signed message ( KRD in ECDAA protocol)
                          KRD,  
                          // Blinded credential R,S,T,W together with c,n ( c,R,S,T,W,n in ECDAA protocol)
                          <
                            // c
                            blind(<h(KRD),blind(blind(<pk(attestSk),issuerSk>,ij),l)>, <r,n>),
                            // R,S,T,W
                            blind(blind(<pk(attestSk),issuerSk>,ij),l),
                            // n
                            n
                          >
                        )
            = true,


            verify_bilinear_pairing( 
                      blind(blind(<pk(attestSk),issuerSk>,ij),l), 
                      pk(issuerSk) 
                    )
            =
            true


/* ******************** Web Authentication Protocol involving entities ******************** */
// User:          A user uses authenticator to authenticate himself/herself during the protocol.
// Authenticator: A cryptographic entity, existing in the TEE world of the local device, can register a 
//                user under a given Server and later assert possession of the registered public key credential, 
//                and optionally verify the user, when requested by the TEE world.
// Client:        Client-side of the protocol, existing in non-TEE world of the local device, processes and forwards the messages
//                exchanging between the Authenticator and the Server.
// Server:        Server-side of the protocol, existing in the remote server, registers and authenticates users during the protocol.
// Issuer:        Issuer of Client & Authenticator, who generates and records ECDAA attestation keys and certs for Clients & Authenticators.
//                In this script, Issuer also sends its public key to Server via secure offline method.



/* ******************** Initialization step ( I1 ) ******************** */
/* ******************** Initialization step ( I1 ) ******************** */
/* ******************** Initialization step ( I1 ) ******************** */
/* ******************** Initialization step ( I1 ) ******************** */
/* ******************** Initialization step ( I1 ) ******************** */


/*  (I1) In the script, the in-factory ECDAA-join mode is considered. In this mode, physical proximity is used 
    to locally establish the trust between the ECDAA-Issuer and the authenticator. The attestation keys
    and credential have been generated by Issuer before Authenticator and Client being shipped.
    *** A attestation key pair "~attestSk" & "pk(~attestSk)" is generated and stored in Authenticator.
    *** A attestation credential has been generated for the attestation key pair and stored 
    ==> The attestation credential are stored both in the flash of Client and Authenticator
    ==> The attestation private key is stored in the flash of Authenticator
*/
rule EcdaaIssuer_InFactorySetup:
      let
        // The public and private key pair of Issuer
        issuerSk = IssuerSk()
        issuerPk = pk(issuerSk)
        // Issuer generates attestation credential to be stored in Authenticator (i.e. blind the credential for the first time)
        attestCred = blind(<pk(~attestSk),issuerSk>, ~ij)
      in
      [ 
        // Nonce ~ij is generated by Issuer to blind the attestation credential for the first time
        Fr( ~ij ),
        // Issuer generates attestation private key to be stored in Authenticator
        Fr( ~attestSk )
      ]
    --[
        IssuerAttestKeyGeneration( $IssuerID, $AAGUID, ~attestSk )
      ]->
      [ 
        // Issuer sends its public key issuerPk to Server via secure offline method
        !Flash( svrToken($SvrID), issuerPk ), 
        // Issuer stores the attestation private key in its Flash
        !Flash( iToken($IssuerID), <~attestSk, attestCred> ),
        // Issuer stores the attestation credential in Client before Client & Authenticator being shipped
        !Flash( nsToken($ClientID), attestCred ),
        // Issuer stores the attestation private key and credential in Authenticator before Client & Authenticator being shipped
        !Flash( sToken($AAGUID), <~attestSk, attestCred> )
      ]


/* ******************** Registration step ( R1~R6 ) ******************** */
/* ******************** Registration step ( R1~R6 ) ******************** */
/* ******************** Registration step ( R1~R6 ) ******************** */
/* ******************** Registration step ( R1~R6 ) ******************** */
/* ******************** Registration step ( R1~R6 ) ******************** */


/* (R1) User sends a registration request (with a $UserName) to Server via Client
*/
rule User_SendRegistrationRequest_to_Server_via_Client:
      [ ] 
    --[ ]->
      [ 
        RAM( nsToken($ClientID), $UserName ), 
        Out(< $SvrID, $ClientID, <$UserName, 'Registration'> >)
      ]


/* (R2) Server (Relying Party) receives the registration request from User via Client,
   generates a challenge ~chalR, and sends ~chalR to Client 
*/
rule Server_PublicKeyCredentialCreationOptions_to_Client:
      [
        In(< $SvrID, $ClientID, <$UserName, 'Registration'> >), 
        Fr( ~chalR ) 
      ] 
      --[]->
      [ 
        RAM( svrToken($SvrID), <$UserName, ~chalR> ), 
        Out(< $SvrID, $ClientID, <$SvrID, $UserName, ~chalR, 'Registration'> >)
      ]


/*  (R3) Client receives the request, blinds the ECDAA credential and sends request to Authenticator.

    NOTE: In ECDAA mode, in order to generate the attestation signature, Client generates a nonce "~l", 
    blinds the attestation credential and sends the blinded attestation credential to Authenticator.
*/
rule Client_AuthenticatorMakeCredential_Request_to_Authen:
      let
          // Client prepares the clientData
          clientData = <chalR, $ClientID>
          clientDataHash = h(clientData)
          // Client blinds the attestation credential
          bldAttCred = blind(attestCred, ~l )
      in
      [
        // Client receives parameters from Server
        In(< $SvrID, $ClientID, <$SvrID, $UserName, chalR, 'Registration'> >),
        // Client reands the attestation credential from its Flash
        !Flash( nsToken($ClientID), attestCred ),
        // Client generates a nonce "~l" to blind the attestation credential
        // and sends the "~l" to the Authenticator to generate ECDAA attestation signature
        Fr( ~l )
      ]
    --[
        SanityCheck1('Arrived')
      ]->
      [
        RAM( nsToken($ClientID), ~l ),
        RAM( nsToken($ClientID), chalR ),
        // Client sends the request for registration data and related attestation signature from Authenticator
        Out(< $ClientID, $AAGUID, <clientDataHash, $SvrID, $UserName, ~l, 'Registration'> >),
        // Client stores the blinded attestation credential in its Flash
        !Flash( nsToken($ClientID), bldAttCred )
      ]


/*  (R4.1) The TEE world shows the registration info to User. With User's verification, 
    the Authenticator generates a pair of authentication keys, and then returns 
    the related authenticator data, and signature signed by the attestation private key.
    
    In this script, the attestation mode is ECDAA attestation, which uses the attestation 
    private key generated by ECDAA Issuer and stored in the Authenticator as the attestation signing key.

    NOTE: a random number ~nonce is used instead of monotonic increasing counter in Authenticator,
    the ~nonce could be constant at zero if Authenticator doesn't support a counter.
*/

rule Authen_AuthenticatorMakeCredential_Response_to_Client:
      let
          // Authenticator computes authenticator data (i.e. AuthData)
          authData = <$SvrID, ~nonce, $AAGUID, pk(~credSk)>
          // Authenticator generates an ECDAA attestation signature using blinded signing
          KRD = <authData, clientDataHash>
          bldAttCred = blind(attestCred, l )                            // R,S,T,W
          c = blind( <h(KRD),bldAttCred>, <~r,~n> )
          bldAttSig = <c, blind_sig(c, attestSk), bldAttCred, ~n>      // c,s,R,S,T,W,n
          attestObj = <authData, bldAttSig>
      in
      [ 
        // Authenticator receives parameters from Client to generate ECDAA attestation signature for registration. 
        // "l" is the nonce from Client
        In(< $ClientID, $AAGUID, <clientDataHash, $SvrID, $UserName, l, 'Registration'> >),
        // Authenticator reads attestaion private key and credential from its flash
        !Flash( sToken($AAGUID), <attestSk, attestCred> ),
        // Authenticator generates authentication credential key pair
        Fr( ~credSk ),
        // The nonce could be constant at zero if the authenticator doesn't support a global or per credential counter
        Fr( ~nonce ),
        // New nonce ~r and ~n are generated by Authenticator to blind the message to be signed
        Fr( ~r ),
        Fr( ~n )
      ]
    --[
        Alive( $AAGUID ),
        UserRegVerification( $SvrID, $AAGUID, $UserName, ~credSk, 'Allow' ),
        AttestationKeyUsed( $SvrID, $AAGUID, $UserName, ~credSk, attestSk ),
        SanityCheck2_1( 'Arrived' )
      ]->
      [ 
        // Authenticator stores credential source (including the authentication key) in the secure Flash
        !Flash( sToken($AAGUID), <$SvrID, $UserName, ~credSk> ),
        // Authenticator sends the attestation object and blinded message to the Client
        // *** "attestObj" includes Authenticator data "authData" (part of the KRD)
        //      and the blind-sign signature "bldAttSig" (i.e. "s")
        // *** "c" is the blinded message blind(blind(KRD,l),r) to be signed
        Out(< $ClientID, $AAGUID, attestObj >)  
      ]


/*  (R4.2) The TEE world shows the registration info to User. With User's rejection, 
    and the Authenticator returns an error 'NowAllowedError' to Client.
*/
rule Authen_User_Reject_AuthenticatorMakeCredential:
      [ 
        In(< $ClientID, $AAGUID, <clientDataHash, $SvrID, $UserName, l, 'Registration'> >) 
      ]
    --[
        Alive( $AAGUID ),
        UserRegVerification( $SvrID, $AAGUID,  $UserName, 'NULL', 'Reject' ),
        SanityCheck2_2('Arrived')
      ]->
      [ 
        // Authenticator User rejects the registration,
        // and Authenticator sends an error to Client.
        Out(< $ClientID, $AAGUID, 'NotAllowedError' >)
      ]


/*  (R5) Client receives the generated attestation object from Authenticator,
    and sends the attestation object together with clientData to Server
*/
rule Client_AuthenticatorAttestationResponse_to_Server:
      let
          clientData = <chalR, $ClientID>
      in
      [ 
        In(< $ClientID, $AAGUID, attestObj >),
        RAM( nsToken($ClientID), chalR )
      ]
    --[
        SanityCheck3('Arrived')
      ]->
      [ 
        // "attestObj" includes Authenticator data "authData" AND the blind-sign signature "bldAttSig"
        // "bltAttSig" includes <c, s, bldAttCred, n> (i.e. <c,s,R,S,T,W,n> in ECDAA protocol)
        Out(< $ClientID, $SvrID, <clientData, attestObj> >)
      ]


/*  (R6) Server checks the chanllenge and verifies the attestation signature for generated credential resource.
    If verification succeeds, Server registers User under UserName, and the generated credential resource.
*/
rule Server_ValidateAttestationAndRegister:
      let
          clientData = <chalR, $ClientID>    // clientData
          clientDataHash = h(clientData)
          authData = <$SvrID, nonce, $AAGUID, pk(credSk)>
          KRD = <authData, clientDataHash>
          bldAttSig = <c, s, bldAttCred, n>     // <c,s,R,S,T,W,n> in ECDAA protocol
          attestObj = <authData, bldAttSig>     // attestObj 
      in
      [ 
        // Server retrieves Issuer's public key issuerPk from its Flash
        !Flash( svrToken($SvrID), issuerPk ), 
        // Server retrieves the challenge "chalR" from its RAM
        RAM( svrToken($SvrID), <$UserName, chalR> ), 
        // Server receives the registration and attestation messages from Client
        In(< $ClientID, $SvrID, <clientData, attestObj> >)
      ]
    --[ 
        ServerRegisterAuthen( $SvrID, $AAGUID, $UserName, pk(credSk) ),
        Eq( verify_blind_sig( s, KRD, <c,bldAttCred,n>), true ),
        Eq( verify_bilinear_pairing( bldAttCred, issuerPk ), true),
        SanityCheck4('Arrived')
      ]->
      [ 
        // Server registers and stores authenticator's ID and public key in its flash
        !Flash( svrToken($SvrID), <$AAGUID, $UserName, pk(credSk)> )
      ]


////////////////////////////////////////////////////////////////////////////
// Server is corrupted, and the attacker can read AND/OR modify
// the Server-related RAM, flash and channels.
////////////////////////////////////////////////////////////////////////////

rule SvrAttacker_Read_SvrFlash:
    [ !Flash(svrToken($SvrID), x) ]   --[ Reveal($SvrID, x) ]->    [ Out(x) ]

rule SvrAttacker_Read_SvrRAM:
    [ RAM(svrToken($SvrID), x) ]  --[ Reveal($SvrID, x) ]->    [ Out(x) ]

// rule SvrAttacker_Read_TLS:    
//     [ TLS( $SvrID, $ClientID, x )   ]  --[ Reveal(<$SvrID,$ClientID>, x) ]->    [ Out(x) ] 

rule SvrAttacker_Write_SvrFlash:
    [ !Flash(svrToken($SvrID), x),  In(y) ]  --[ Modification($SvrID, x, y) ]->    [ !Flash(svrToken($SvrID), y) ]

rule SvrAttacker_Write_SvrRAM:
    [ RAM(svrToken($SvrID), x),  In(y) ]   --[ Modification($SvrID, x, y) ]->    [ !Flash(svrToken($SvrID), y) ]

// rule SvrAttacker_Write_TLS:    
//     [ TLS( $SvrID, $ClientID, x ),  In( y )   ]  --[ Modification(<$SvrID,$ClientID>, x, y) ]->    [ TLS( $SvrID, $ClientID, y ) ] 


////////////////////////////////////////////////////////////////////////////
// Secure world is corrupted, and the attacker can read AND/OR modify
// the Secure-world-related RAM, flash and channels.
////////////////////////////////////////////////////////////////////////////

rule SwAttacker_Read_SwFlash:
    [ !Flash(sToken($AAGUID), x) ]   --[ Reveal($AAGUID, x) ]->    [ Out(x) ]

rule SwAttacker_Read_SwRAM:
    [ RAM(sToken($AAGUID), x) ]  --[ Reveal($AAGUID, x) ]->    [ Out(x) ]

rule SwAttacker_Read_LOC:    
    [ LOC( $ClientID, $AAGUID, x )   ]  --[ Reveal(<$ClientID,$AAGUID>, x) ]->    [ Out(x) ] 

// rule SwAttacker_Write_SwFlash:
//     [ !Flash(sToken($AAGUID), x),  In(y) ]  --[ Modification($AAGUID, x, y) ]->    [ !Flash(sToken($AAGUID), y) ]

// rule SwAttacker_Write_SwRAM:
//     [ RAM(sToken($AAGUID), x),  In(y) ]   --[ Modification($AAGUID, x, y) ]->    [ !Flash(sToken($AAGUID), y) ]

// rule SwAttacker_Write_LOC:    
//     [ LOC( $ClientID, $AAGUID, x ),  In( y )   ]  --[ Modification(<$ClientID,$AAGUID>, x, y) ]->    [ LOC( $ClientID, $AAGUID, y ) ] 


////////////////////////////////////////////////////////////////////////////
// Non-secure world is corrupted, and the attacker can read AND/OR modify
// the NS-World-related RAM, flash and channels.
////////////////////////////////////////////////////////////////////////////

rule NswAttacker_Read_NswFlash:
    [ !Flash(nsToken($ClientID), x)  ]   --[ Reveal($ClientID, x) ]->    [ Out(x) ]

rule NswAttacker_Read_NswRAM:
    [ RAM(nsToken($ClientID), x)   ]  --[ Reveal($ClientID, x) ]->    [ Out(x) ]    

// rule NswAttacker_Read_LOC:    
//     [ LOC( $ClientID, $AAGUID, x )   ]  --[ Reveal(<$ClientID,$AAGUID>, x) ]->    [ Out(x) ] 

// rule NswAttacker_Read_TLS:    
//     [ TLS( $SvrID, $ClientID, x )   ]  --[ Reveal(<$SvrID,$ClientID>, x) ]->    [ Out(x) ] 

rule NswAttacker_Write_NswFlash:
    [ !Flash(nsToken($ClientID), x),  In( y ) ]  --[ Modification($ClientID, x, y) ]->    [ !Flash(nsToken($ClientID), y) ]

rule NswAttacker_Write_NswRAM:
    [ RAM(nsToken($ClientID), x),  In( y ) ]   --[ Modification($ClientID, x, y) ]->    [ !Flash(nsToken($ClientID), y) ]

// rule NswAttacker_Write_LOC:    
//     [ LOC( $ClientID, $AAGUID, x ),  In( y )   ]  --[ Modification(<$ClientID,$AAGUID>, x, y) ]->    [ LOC( $ClientID, $AAGUID, y ) ] 

// rule NswAttacker_Write_TLS:    
//     [ TLS( $SvrID, $ClientID, x ),  In( y )   ]  --[ Modification(<$SvrID,$ClientID>, x, y) ]->    [ TLS( $SvrID, $ClientID, y ) ] 


/* ******************** End of the protocol rules ******************** */
/* ******************** End of the protocol rules ******************** */
/* ******************** End of the protocol rules ******************** */
/* ******************** End of the protocol rules ******************** */
/* ******************** End of the protocol rules ******************** */


restriction Equality:
  "
    All x y #i. Eq(x,y) @i ==> x = y
  "


/* ******************** SANITY CHECK ******************** */
/* ******************** SANITY CHECK ******************** */
/* ******************** SANITY CHECK ******************** */
/* ******************** SANITY CHECK ******************** */
/* ******************** SANITY CHECK ******************** */


// lemma SanityCheck1 [use_induction]:
// exists-trace "Ex #i. SanityCheck1('Arrived') @ #i"

// lemma SanityCheck2_1 [use_induction]:
// exists-trace "Ex #i. SanityCheck2_1('Arrived') @ #i"

// lemma SanityCheck2_2 [use_induction]:
// exists-trace "Ex #i. SanityCheck2_2('Arrived') @ #i"

// lemma SanityCheck3 [use_induction]:
// exists-trace "Ex #i. SanityCheck3('Arrived') @ #i"

// lemma SanityCheck4 [use_induction]:
// exists-trace "Ex #i. SanityCheck4('Arrived') @ #i"


/* **************************************** SECRECY **************************************** */
/* **************************************** SECRECY **************************************** */
/* **************************************** SECRECY **************************************** */
/* **************************************** SECRECY **************************************** */
/* **************************************** SECRECY **************************************** */


lemma authentication_private_key_secrecy:
    "(All #i1 #i2 svrID aaguID userName credSk.
    (
      // Once User has allowed Authenticator to generate authentication key credSk,
      UserRegVerification( svrID, aaguID, userName, credSk, 'Allow' ) @ i1
      &
      // and credSk is verified and registered by the Server during attestation,
      ServerRegisterAuthen( svrID, aaguID, userName, pk(credSk) ) @ i2
    )
    // then the attacker can't get the credential private key credSk
    ==> not (Ex #i3. K( credSk ) @ i3 )
  )"


lemma attestation_private_key_secrecy:

    "(All #i1 #i2 #i3 svrID aaguID manuID userName credSk attestSk.
    (
      // If Manufacturer generates attestation key pair for Authenticator (aaguID),
      IssuerAttestKeyGeneration( manuID, aaguID, attestSk ) @ i1
      &
      // and attestSk is used to generate attestation signature by Authenticator,
      AttestationKeyUsed( svrID, aaguID, userName, credSk, attestSk ) @ i2
      &
      // and Server verifies and registers and pk(credSk) after attestation,
      ServerRegisterAuthen( svrID, aaguID, userName, pk(credSk) ) @ i3
    )
    ==> 
    // then the attacker can't get the attestation private key attestSk
      not ( Ex #i4. K( attestSk ) @ i4 )
  )"


/* **************************************** Authentication **************************************** */
/* **************************************** Authentication **************************************** */
/* **************************************** Authentication **************************************** */
/* **************************************** Authentication **************************************** */
/* **************************************** Authentication **************************************** */


lemma aliveness:
"
  ( All #i svrID aaguID userName credSk.
      ServerRegisterAuthen( svrID, aaguID, userName, pk(credSk) ) @ i
    ==> 
      ( Ex #j. Alive( aaguID ) @ j )
  )
"


// lemma weak_agreement:
// "
//   ( All #i svrID aaguID userName credSk1.
//       ServerRegisterAuthen( svrID, aaguID, userName, pk(credSk1) ) @ i
//     ==> 
//       ( 
//         Ex credSk2 #j. 
//         UserRegVerification( svrID, aaguID, userName, credSk2, 'Allow' ) @ j
//        )
//   )
// "


// lemma ni_agreement:
// "
//   ( All #i svrID aaguID userName credSk.
//       ServerRegisterAuthen( svrID, aaguID, userName, pk(credSk) ) @ i
//     ==> 
//       ( 
//         Ex #j. 
//         UserRegVerification( svrID, aaguID, userName, credSk, 'Allow' ) @ j
//       )
//   )
// "


// lemma i_agreement:
// "
//   ( All #i svrID aaguID userName credSk.
//       ServerRegisterAuthen( svrID, aaguID, userName, pk(credSk) ) @ i
//     ==> 
//       ( 
//         Ex #j. 
//         UserRegVerification( svrID, aaguID, userName, credSk, 'Allow' ) @ j
//         & #j < #i
//         & not ( Ex svrID2 aaguID2 userName2 #i2. 
//                    ServerRegisterAuthen( svrID2, aaguID2, userName2, pk(credSk) ) @ i2
//                 &  not (#i2 = #i)
//               )
//       )
//   )
// "


end